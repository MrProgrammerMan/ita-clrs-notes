---
title: 1.1 Algorithms
id: 20250720125550
tags:
---

# 1.1 Algorithms
An **algorithm** transforms values (input) into other values(output) in finite time. It does so through well-defined steps. It could be viewed as a tool for solving a problem defining an input/output relationship which the algorithm achieves, solving the problem.

A formal problem(the sorting problem):
**Input**: A sequence of numbers $<a_1, a_2, a_3 â€¦ a_n>$
**Output**: A permutation $<a'_1, a'_2, a'_3 ... a'_n>$ of the input sequence such that $a_1 \le a_2 \le a_3 \le ... \le a_n$.

An **input sequence**, say, $<12, 65, 23, 2, 5, 8>$ is called an **instance** of the sorting problem.
Sorting is often an intermidiary step in computer problems and is extremely common.

An algorithm is considered **correct** and to be a **solution** to a sorting problem if it provides the correct solution in finite time for every provided problem instance. Incorrect algorithms with controllable error rates can be useful in certain situations.

As long as an algorithm is precise, there are no formal requirements.

## What kinds of problems do algorithms solve?
- Sorting
- Manipulating big data for web and AI
- Cryptography used in secure communication
- Resource allocation and estimation
- Map system routes
- File compression
- Image recognition and categorization
- Many, many more...

Many of the above problems have many candidate solutions, and it can be challenging to determine the best one. Other problems may be far more difficult to determine candidate solutions for, such as the Fast Fourier Transform(FFT) for converting discrete signals to a continuous one as a sum of sine waves.

## Data structures
A data structure is a way to organize data and greatly impacts algorithm design. They each have different use cases and pros/cons.

## Technique
Designing algorithms can be challenging, but often utilize common techniques for known problems. Knowing these techniques and use cases of them will make it easier to identify solutions to new problems.

## Hard problems
Many common problems have established efficient algorithms, meaning they terminate in a reasonable amount of time. A subset of the problems that have no known efficient solution are **NP-complete** problems. Noone has proven that no efficient algorithm exists for these problems, and they share the property that an efficient algorithm for one would mean an efficient algorithm for all. Therefore, these problems are very tempting to find an efficient algorithm for. They can often be strikingly similar to problems of which we _do_ know of an efficient algorithm. Changing the problem slightly can make it a lot harder to solve.

NP-complete problems are important because they are very common. If you can prove a problem is NP-complete, you can find a good estimation algorithm instead of wasting time trying to solve the problem outright.

An example is the traveling salesperson problem, where the most efficient route between many arbitrary stops on a map must be determined.

## Alternative computing models
We must account for practical limitations when designing algorithms.

In order for an algorithm to be able to run parallelized it must be designed to do so. This is important for algorithms that cant be run fast enough on a single core.

In the real world its often the case that not all input data arrives at once for an algorithm. Algorithms that can process while the input data is arriving are _online_.